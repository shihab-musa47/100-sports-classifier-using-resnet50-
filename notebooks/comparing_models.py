# -*- coding: utf-8 -*-
"""comparing models.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LYkb5JvIB_gA8wDNsoeJ_WvFa9tMCXBI
"""

bs = 32 # batch size
version = 1

!pip install -Uqq fastai

from fastai import *
from fastai.vision.all import *
from fastai.vision.widgets import *

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/drive/My Drive/capstone2/sports image classifier

data_path = "data"
dblock = DataBlock(
    blocks=(ImageBlock, CategoryBlock),
    get_items=get_image_files,                        # get_image_files returns a list of all images in that path recursively by default
    splitter=RandomSplitter(valid_pct=0.1, seed=42),  # getting 90-10 train-validation split
    get_y=parent_label,                               # taking the folder name as labels
    item_tfms=Resize(128))                            # resizing to get the image of same shape

import torch
dls = torch.load('sports_dataloader_v0.pkl', weights_only=False)

dblock = dblock.new(item_tfms=RandomResizedCrop(224, min_scale=0.5), batch_tfms=aug_transforms())
dls = dblock.dataloaders(data_path, bs = bs)

import torch
torch.save(dls, "sports_dataloader_v0.pkl")

dls.train.show_batch(max_n=8, nrows=2)

dls.valid.show_batch(max_n=8, nrows=2)

"""TRAINING AND DATA CLEANING

"""

model_path = "models"

from torchvision.models import mobilenet_v2

learn_mobilenet = vision_learner(
    dls,
    'mobilenetv2_100', # Changed from 'mobilenet_v2' to 'mobilenetv2_100' for timm compatibility
    metrics=[error_rate, accuracy]
)

learn_mobilenet.fine_tune(5)

learn_mobilenet.export('mobilenet_v2_model.pkl')

from torchvision.models import resnet50

learn_resnet50 = vision_learner(
    dls,
    resnet50,
    metrics=[error_rate, accuracy]
)

learn_resnet50.fine_tune(5)

learn_resnet50.export('resnet50_model.pkl')

from torchvision.models import efficientnet_b0

learn_efficientnet = vision_learner(
    dls,
    efficientnet_b0,
    metrics=[error_rate, accuracy]
)

learn_efficientnet.fine_tune(5)

learn_efficientnet.export('efficientnet_b0_model.pkl')

from fastai.vision.all import *

learn = load_learner('resnet50_model.pkl')

model = load_learner('resnet50_model.pkl')



from fastai.vision.all import *
import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay
import numpy as np

# Load the model
model = load_learner('resnet50_model.pkl')

# Get predictions on validation set
# The model already has the dataloaders embedded
preds, targets = model.get_preds(dl=dls.valid) # Added dl=dls.valid here

# Convert to class indices
pred_classes = preds.argmax(dim=1)

# Create confusion matrix
cm = confusion_matrix(targets, pred_classes)

# Plot confusion matrix
fig, ax = plt.subplots(figsize=(20, 20))
disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=model.dls.vocab)
disp.plot(ax=ax, xticks_rotation=90, cmap='Blues')
plt.title('Confusion Matrix - Sports Classification', fontsize=16)
plt.tight_layout()
plt.show()

# Print accuracy and most confused classes
accuracy = (pred_classes == targets).float().mean()
print(f"\nâœ… Overall Accuracy: {accuracy:.4f} ({accuracy*100:.2f}%)")

# Find most confused pairs
print("\nðŸ”€ Most Confused Sport Pairs:")
np.fill_diagonal(cm, 0)  # Remove diagonal (correct predictions)
confused_pairs = []
for i in range(len(cm)):
    for j in range(len(cm)):
        if cm[i, j] > 0:
            confused_pairs.append((cm[i, j], model.dls.vocab[i], model.dls.vocab[j]))

confused_pairs.sort(reverse=True)
for count, true_label, pred_label in confused_pairs[:10]:
    print(f"  {count:3d}x  '{true_label}' predicted as '{pred_label}'")